\documentclass[10pt, a4paper, hidelinks]{article}
\usepackage[paper=a4paper, left=2cm, right=2cm, bottom=2cm, top=3cm]{geometry} %ajustar márgnens
\usepackage[latin1]{inputenc}
\usepackage[spanish]{babel}
\usepackage{caratula}
\usepackage{enumitem} 
\usepackage{hyperref}
\usepackage{mathtools}
\usepackage[font=small,labelfont=bf]{caption}
\newcommand\floor[1]{\lfloor#1\rfloor}
\newcommand\ceil[1]{\lceil#1\rceil}
%\usepackage{clrscode3e} Estilo Cormen
\usepackage[spanish,onelanguage,ruled,vlined,nofillcomment]{algorithm2e}
\usepackage{algpseudocode}
\usepackage{xcolor}
%%%%%%%%%%%%%% Formato de párrafos %%%%%%%%%%%%%%%%%%
\setlength{\parindent}{2em}
\setlength{\parskip}{3pt}
%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
\usepackage{fancyhdr}
\usepackage{lastpage}
\setlength{\intextsep}{0.2cm}
\pagestyle{fancy}
\lhead{Algoritmos y Estructuras de Datos III}
\rhead{$2^{\mathrm{do}}$ cuatrimestre de 2017}

\LinesNumbered
\DontPrintSemicolon

\newcommand{\comp}[1]{$\mathcal{O}(#1)$}

%%%%%%%%%%%%%%%%%%% Macro para comentar codigo %%%%%%%%%%%%%%%%%%%%%%%%%
\newcommand{\comentario}[1]{
\SetKwComment{Comment}{/* }{ */}
\textcolor{blue}{\Comment*[h]{{#1}}}
}
%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%

\begin{document}

\materia{Sistemas Operativos}
\submateria{Primer cuatrimestre del 2018}
\titulo{Trabajo Práctico 1: $pthreads$}
\integrante{Budiño, Gabriel}{046/16}{gabriel.f.budi@gmail.com} % obligatorio 
\integrante{Garro, Damián}{354/16}{damian.garro.mst@gmail.com} % obligatorio 
\integrante{Rozen (?}{xxx/xx}{ mail } % obligatorio 

\maketitle

\tableofcontents
\pagenumbering{gobble}

\pagebreak
\pagenumbering{arabic}
\cfoot{\thepage /\pageref{LastPage}}

\section{Introducción}
Para este trabajo se debía implementar la clase ConcurrentHashMap, una tabla de $hash$ abierta con interfaz de Map (i.e, diccionario) preparada para ser usada por $threads$ concurrentes. 

Se presenta en este informe un breve resumen de la resolución de cada ejercicio y la experimentación y pruebas realizadas. En el Apéndice A se encuentra el enunciado del trabajo.
  
\section{Resolución}
\subsection{Ejercicio 1}
El primer paso era completar la clase ListaAtomica entregada por la cátedra implementando push\_front de manera que no haya peligro de $race$ $conditions$. 

Para esta operación se crea un nuevo nodo con el valor pasado a como parámetro, $nuevo$, y se hace que apunte como siguiente al actual primer nodo, $head$. Acá faltaría solo asignar $nuevo$ a $head$ de modo que éste sea el actual primer nodo, pero podría pasar que entre la asignación de $nuevo\rightarrow next$ y este último paso alguien más haga un push\_front, no cumpliendo así la condición de que no haya peligro de $race$ $conditions$. Para resolver esto, se realiza esa asignación de la siguiente manera:

while (not atomic\_compare\_exchange\_weak(\&$head$, \&$nuevo\rightarrow next$,$nuevo$))

La función dentro de la guarda se comporta así:
\begin{itemize}
\item Si $head$ es igual a $nuevo\rightarrow next$ (i.e, si el $head$ no cambio desde que hicimos que $nuevo$ lo apunte), devuelve True y asigna a $head$, $nuevo$.
\item Si se da el caso contrario (i.e, el $head$ cambio desde que hicimos que $nuevo$ lo apunte), devuelve False y asigna a $nuevo\rightarrow next$, $head$, es decir, hace que $nuevo$ apunte al $head$ correcto.
\end{itemize}

Como la misma se encutra negada dentro de un while, solo se vuelve del llamado de push\_front cuando no hay peligro de incoherencias a causa del orden de ejecución.

Luego habia que implementar la clase \texttt{ConcurrentHashMap}, cuya representación interna es un vector de listas de pares de 26 entradas, \texttt{tabla} (una por cada letra) y un vector de mutexs (mutexes?), \texttt{mutexes} de igual cantidad de entradas.

Para el constructor, \texttt{ConcurrentHashMap()}, simplemente se crea en cada entrada de \texttt{tabla} una nueva lista de pares vacía.

Para la función \texttt{void addAndInc(string key)}, se define $i$ como la entrada de \texttt{tabla} a la cual debe ir a parar $key$ en base a su primer caracter (esa es la función de $hash$) y se $lockea$ el mutex en la entrada $i$ de \texttt{mutexes}. Con un iterador se recorre la lista en la entrada $i$ de \texttt{tabla}, si clave existe se incrementa su valor, sino se hace \texttt{push\_front} de la misma. Finalmente se $unlockea$ (no se como ponerle XD) el mutex. 

Para la función \texttt{bool member(string key)}, simplemente se obtiene $i$ de la misma forma que antes y se recorre la entrada correspondiente de \texttt{tabla} con un iterador, si el elemento está se devuelve True y en caso contrario se devuelve False.

\subsection{Ejercicio 2}
\subsection{Ejercicio 3}
\subsection{Ejercicio 4}
\subsection{Ejercicio 5}
\subsection{Ejercicio 6}

\section{Experimentación}

\section{Apéndice A}

\end{document}

