\documentclass[10pt, a4paper, hidelinks]{article}
\usepackage[paper=a4paper, left=2cm, right=2cm, bottom=2cm, top=3cm]{geometry} %ajustar márgnens
\usepackage[latin1]{inputenc}
\usepackage[spanish]{babel}
\usepackage{caratula}
\usepackage{enumitem} 
\usepackage{hyperref}
\usepackage{mathtools}
\usepackage[font=small,labelfont=bf]{caption}
\newcommand\floor[1]{\lfloor#1\rfloor}
\newcommand\ceil[1]{\lceil#1\rceil}
%\usepackage{clrscode3e} Estilo Cormen
\usepackage[spanish,onelanguage,ruled,vlined,nofillcomment]{algorithm2e}
\usepackage{algpseudocode}
\usepackage{xcolor}
\usepackage[final]{pdfpages} % para agregar el enunciado
%%%%%%%%%%%%%% Formato de párrafos %%%%%%%%%%%%%%%%%%
\setlength{\parindent}{2em}
\setlength{\parskip}{3pt}
%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
\usepackage{fancyhdr}
\usepackage{lastpage}
\setlength{\intextsep}{0.2cm}
\pagestyle{fancy}
\lhead{Sistemas Operativos}
\rhead{$1^{\mathrm{er}}$ cuatrimestre de 2018}

\LinesNumbered
\DontPrintSemicolon

\newcommand{\comp}[1]{$\mathcal{O}(#1)$}

%%%%%%%%%%%%%%%%%%% Macro para comentar codigo %%%%%%%%%%%%%%%%%%%%%%%%%
\newcommand{\comentario}[1]{
\SetKwComment{Comment}{/* }{ */}
\textcolor{blue}{\Comment*[h]{{#1}}}
}
%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%

\begin{document}

\materia{Sistemas Operativos}
\submateria{Primer cuatrimestre del 2018}
\titulo{Trabajo Práctico 1: \texttt{pthreads}}
\integrante{Budiño, Gabriel Fabricio}{046/16}{gabriel.f.budi@gmail.com} % obligatorio 
\integrante{Garro, Damián Eugenio}{354/16}{damian.garro.mst@gmail.com} % obligatorio 
\integrante{Rozenberg, Uriel Jonathan}{838/12}{rozenberguriel@gmail.com} % obligatorio 

\maketitle

\tableofcontents
\pagenumbering{gobble}

\pagebreak
\pagenumbering{arabic}
\cfoot{\thepage /\pageref{LastPage}}

\section{Introducción}
Para este trabajo se debía implementar la clase ConcurrentHashMap, una tabla de $hash$ abierta con interfaz de Map (i.e, diccionario) preparada para ser usada por $threads$ concurrentes. 

Se presenta en este informe un breve resumen de la resolución de cada ejercicio y la experimentación y pruebas realizadas. En el Apéndice A se encuentra el enunciado del trabajo.


\section{Resolución}
\subsection{Ejercicio 1}

El primer paso era completar la clase \texttt{ListaAtomica} entregada por la cátedra implementando \texttt{push\_front} de manera que sea \textit{atómica} y no haya peligro de $race$ $conditions$. 

Para esta operación se crea un nuevo nodo con el valor pasado a como parámetro, \texttt{nuevo}, y se hace que apunte como siguiente al actual primer nodo, \texttt{head}. Acá faltaría solo asignar \texttt{nuevo} a \texttt{head} de modo que éste sea el actual primer nodo, pero podría pasar que entre la asignación de \texttt{nuevo$\rightarrow$next} y este último paso alguien más haga un \texttt{push\_front}, no cumpliendo así la condición de que no haya peligro de $race$ $conditions$. Para resolver esto, se realiza esa asignación de la siguiente manera:

\texttt{while (not atomic\_compare\_exchange\_weak(\&head, \&nuevo$\rightarrow$next,nuevo))}

La función dentro de la guarda se comporta así, de forma atómica:
\begin{itemize}
\item Si \texttt{head} es igual a \texttt{nuevo$\rightarrow$next} (i.e, si el \texttt{head} no cambió desde que hicimos que \texttt{nuevo} lo apunte), devuelve True y asigna a \texttt{head}, \texttt{nuevo}.
\item Si se da el caso contrario (i.e, el \texttt{head} cambio desde que hicimos que \texttt{nuevo} lo apunte), devuelve False y asigna a \texttt{nuevo$\rightarrow$next}, \texttt{head}, es decir, hace que \texttt{nuevo} apunte al \texttt{head} correcto.
\end{itemize}

Como la misma se encuentra negada dentro de un while, solo se vuelve del llamado de \texttt{push\_front} cuando no hay peligro de incoherencias a causa del orden de ejecución.

Luego había que implementar la clase \texttt{ConcurrentHashMap}, cuya representación interna es un vector de listas de pares de 26 entradas, \texttt{tabla} (una por cada letra) y un vector de mutex, \texttt{mutexes} de igual cantidad de entradas. 

Para el constructor, \texttt{ConcurrentHashMap()}, simplemente se crea en cada entrada de \texttt{tabla} una nueva lista de pares vacía.

Para la función \texttt{void addAndInc(string key)} se debía garantizar contensión solo en caso de colisión de $hash$. Para lograr esto, se hace $locking$ en la entrada de \texttt{tabla} que se va a modificar usando el arreglo \texttt{mutexes}, de manera que ejecuciones concurrentes se permitan siempre que se trate de escrituras a distintas listas.  


\begin{algorithm}[H]

\SetKwProg{Fn}{Función}{}{fin}

\SetAlgoLined
\Fn{addAndInc(key)}{
	\texttt{i} $\leftarrow$ función de hash de \texttt{key} \\
	\texttt{mutexes[i].lock} \\
	iterar \texttt{tabla[i]} buscando \texttt{key} \\
	\If{está} {sumar 1 a su valor}
    \Else{\texttt{tabla[i].push\_front(key)}}
    \texttt{mutexes[i].unlock} \\
}
\caption{addAndInc}
\end{algorithm} 

Para la función \texttt{bool member(string key)}, simplemente se obtiene \texttt{i} de la misma forma que antes y se recorre la entrada correspondiente de \texttt{tabla} con un iterador, si el elemento está se devuelve True y en caso contrario se devuelve False. Esta operación es \textit{wait free} ya que no se aplica ningún mecanismo de $locking$. Podría ocurrir que en el medio de la operación se ejecute un \texttt{push\_front} del elemento buscado, y que \texttt{member} devolviese False o True dependiendo de si ya había empezado a recorrer la entrada de la tabla o no. Esto no es un problema, porque ambos resultados se corresponden con una posible ejecución secuencial de las operaciones.

Para la función \texttt{pair<string, unsigned int>maximum(unsigned int nt)} se definieron una una estructura y una función auxiliar, así que primero explicamos eso.

Se definió antes una estructura \texttt{Busqueda}, compuesta por un un puntero \texttt{ConcurrentHashMap} \texttt{mapa}, un entero atómico \texttt{contador}, un par \texttt{max} y un mutex \texttt{mtx\_max}. 

También se definió la función \texttt{void* buscador(void* data)}, cuyo pseudocódigo es el siguiente.

\begin{algorithm}[H]
\SetKwProg{Fn}{Función}{}{fin}

\SetAlgoLined
\Fn{buscador(data)}{
	\texttt{busqueda} $\leftarrow$ \texttt{data} como puntero a \texttt{Busqueda} \\
	\texttt{max} $\leftarrow$ \texttt{($``"$, 0)} \\
	\While{\texttt{true}} {
		\texttt{i} $\leftarrow$ \texttt{busqueda.contador++} \\
		\If{\texttt{i} $> 25$} {terminar}	
		iterar \texttt{busqueda.mapa[i]}\\
		\If{algún elemento tiene valor mayor al valor de \texttt{max}}{
		actualizar \texttt{max} con ese elemento		
		}
	}
	\texttt{busqueda.mtx\_max.lock} \\
	\If{el valor de \texttt{max} es mayor que el del \texttt{busqueda.max}}{
		\texttt{busqueda.max} $\leftarrow$ \texttt{max} \\
	}
	\texttt{busqueda.mtx\_max.unlock} \\
}
\caption{buscador}
\end{algorithm} 

Originalmente la guarda del \texttt{while} era \texttt{i} $< 26$, pero vimos que un scheduling particular podría traer errores luego haciendo que un $thread$ intente iterar una entrada mayor a 25, por lo que se cambio la guarda a \texttt{true} y luego de la asignación de \texttt{i}, si resulta este ser mayor o igual a 26 se hace un \texttt{break}. La única sección crítica acá es la actualización del máximo, que se resolvió usando $locking$ con el mutex interno de la estructura \texttt{Busqueda}.

Ahora, haciendo uso de la estructura y la función mencionadas, el pseudocódigo de \texttt{maximum} es el siguiente.

\begin{algorithm}[H]
\SetKwProg{Fn}{Función}{}{fin}

\SetAlgoLined
\Fn{maximum(nt)}{
	lock a todas las entradas de \texttt{mutexes} \\
	\texttt{busqueda} $\leftarrow$ nueva \texttt{Busqueda} \\
	\texttt{busqueda.mapa} $\leftarrow$ \texttt{this} \\
	\texttt{busqueda.contador} $\leftarrow$ \texttt{0} \\
	\texttt{busqueda.max} $\leftarrow$ \texttt{($``"$, 0)} \\
	crear \texttt{nt} threads y pasarles \texttt{busqueda} y la función \texttt{buscador} como punto de inicio \\
	esperar que terminen los \texttt{nt} threads \\
	unlock a todas las entradas de \texttt{mutexes} \\
	devolver \texttt{busqueda.max}
}
\caption{maximum}
\end{algorithm} 

Este ejercicio pedía concurrencia interna, la cual se logra usando el entero atómico \texttt{contador}, esto me asegura que durante la ejecución de \texttt{maximum} cada $thread$ va a trabajar sobre una entrada diferente. Aún así, para asegurarnos de que no sea concurrente con \texttt{addAndInc} se debe hacer lock a todos las entradas de \texttt{mutexes} y unlock solo al terminar. 

\subsection{Ejercicio 2}

En este punto no debíamos preocuparnos por la concurrencia. Así que la función  \texttt{count\_words(string arch)} es simplemente abrir el arhivo \texttt{arch} e ir pasando los strings capturados a un \texttt{ConcurrentHashMap} haciendo uso de \texttt{addAndInc}.

En lugar de hacer esto directamente, implementamos una función \texttt{meterEnMapa(ConcurrentHashMap* mapa, string arch)} que toma un puntero a \texttt{ConcurrentHashMap} y un archivo y hace lo descripto anteriormente. Esto es porque es algo que vamos a usar mucho. Luego, \texttt{count\_words(string arch)} solo crea un \texttt{ConcurrentHashMap} \texttt{mapa} y lo llena usando \texttt{meterEnMapa} antes de devolverlo.

\subsection{Ejercicio 3}

Para este ejercicio se volvieron a definir una estructura y una función para ayudarnos. La estructura \texttt{Wrapper\_count\_words1} consta de un puntero a \texttt{ConcurrentHashMap mapa} y un \texttt{string arch}. La función \texttt{void* thread\_count\_words1(void* data)} castea \texttt{data} a un puntero a \texttt{Wrapper\_count\_words1} \texttt{wrap} y luego llama a \texttt{meterEnMapa} con \texttt{wrap$\rightarrow$mapa} y \texttt{wrap$\rightarrow$arch} como parámetros.

Usando la función y la estructura recien definidas, el pseudocódigo de \texttt{count\_words} es el siguiente.

\begin{algorithm}[H]
\SetKwProg{Fn}{Función}{}{fin}

\SetAlgoLined
\Fn{count\_words(archs)}{
	\texttt{nt} $\leftarrow$ largo de \texttt{archs} \\
	\texttt{mapa} $\leftarrow$ nuevo \texttt{ConcurrentHashMap} \\
	\texttt{wrap} $\leftarrow$ arreglo de \texttt{nt} \texttt{Wrapper\_count\_words1} \\
	\ForEach{entrada de \texttt{wrap}}{
		asignarle un archivo disntinto de \texttt{archs} y la dirección de \texttt{mapa}	
	}
	crear \texttt{nt} threads y pasarle una entrada de \texttt{wrap} y \texttt{thread\_count\_words1} como punto de inicio \\
	esperar que terminen los \texttt{nt} threads \\
	devolver \texttt{mapa}
}
\caption{count\_words del Ejercicio 3}
\end{algorithm} 

Cada $thread$ tiene en su \texttt{wrap} un archivo distinto, pero todos tienen el mismo \texttt{mapa}, por lo que al final éste contiene los datos de todos los archivos.

\subsection{Ejercicio 4}

Se definió la estructura \texttt{Wrapper\_count\_words2}, que consta de un puntero a \texttt{ConcurrentHashMap mapa}, un puntero a mutex \texttt{mutexLista} y dos iteradores de lista de string, \texttt{it} y \texttt{ends}.

La función \texttt{thread\_count\_words2} tiene el siguiente pseudocodigo:

\begin{algorithm}[H]
\SetKwProg{Fn}{Función}{}{fin}

\SetAlgoLined
\Fn{thread\_count\_words2($data$)}{
	\texttt{wrap} $\leftarrow$ \texttt{data} como puntero a \texttt{Wrapper\_count\_words2} \\
	\texttt{arch} $\leftarrow$ nuevo string \\
	\While{true}{
		\texttt{wrap.mutexLista.lock} \\
		\If{\texttt{wrap.it} == \texttt{wrap.ends}}{
			\texttt{wrap.mutexLista.unlock} \\
			terminar	
		}
		\texttt{arch} $\leftarrow$ \texttt{wrap.it} \\
		\texttt{wrap.it++} \\
		\texttt{wrap.mutexLista.unlock} \\
		\texttt{meterEnMapa(wrap.mapa, arch)} \\
	}
}
\caption{thread\_count\_words2}
\end{algorithm}

Esta será la función con la que iniciemos los $threads$ de este punto. Usamos los iteradores \texttt{it} y \texttt{ends} para saber cuando se han tomado todos los archivos de la lista, siendo \texttt{it} el que apunta al siguiente archivo aún no tomado y \texttt{ends} el final de la lista. La modificación de estos iteradores está contenida con $locking$ usando el mutex de \texttt{Wrapper\_count\_words2}.

Así, el pseudocódigo de \texttt{count\_words(unsigned int n, list<string>archs)} es el siguiente:

\begin{algorithm}[H]
\SetKwProg{Fn}{Función}{}{fin}

\SetAlgoLined
\Fn{count\_words($n$, $archs$)}{
	\texttt{mapa} $\leftarrow$ nuevo \texttt{ConcurrentHashMap} \\
	\texttt{wrap} $\leftarrow$ nuevo \texttt{Wrapper\_count\_words2} \\
	\texttt{wrap.mapa} $\leftarrow$ dirección de \texttt{mapa} \\
	\texttt{wrap.mutexLista} $\leftarrow$ nuevo mutex \\
	\texttt{wrap.it} $\leftarrow$ \texttt{archs.begin} \\
	\texttt{wrap.ends} $\leftarrow$ \texttt{archs.end} \\
	crear \texttt{n} threads con el puntero a \texttt{wrap} y la función \texttt{thread\_count\_words2} como punto de inicio \\
	esperar que que terminen los \texttt{n} threads \\
	devolver \texttt{mapa}
}
\caption{count\_words del Ejercicio 4}
\end{algorithm}

Notar que los \texttt{n} threads comparten el mismo \texttt{ConcurrentHashMap}. Cada uno se encargará de archivos diferentes (gracias a \texttt{mutexLista}) hasta que no queden más sin cargar en la lista como se vió en la función definida antes, y la contensión está cubierta por \texttt{addAndInc}.

\subsection{Ejercicio 5}

La estructura \texttt{Wrapper\_maximum} es similar a la anterior, consta de un puntero a \texttt{ConcurrentHashMap mapa}, uno a mutex \texttt{mutexLista}, y dos a iteradores de lista de string, \texttt{it} y \texttt{ends}. Básicamente, los que en la anterior eran iteradores, acá son punteros a los mismos. Esto lo hicimos de esta manera porque cada $thread$ va a armar un \texttt{mapa} distinto, así que cada uno trabaja con un \texttt{wrap} diferente, por lo que necesitamos pasarle punteros a los iteradores para que todos compartan los mismos (y así nos aseguramos de que carguen archivos distintos).

A su vez, la función auxiliar \texttt{thread\_maximum} es casi idéntica a \texttt{thread\_count\_words2}. La única diferencia es que al tratar con \texttt{it} y \texttt{ends}, hay que desreferenciarlos.

El pseudocódigo de \texttt{maximum(unsigned int p\_archivos, unsigned int p\_maximos, list<string>archs)} es el siguiente:

\begin{algorithm}[H]
\SetKwProg{Fn}{Función}{}{fin}

\SetAlgoLined
\Fn{maximum(p\_archivos, p\_maximos, archs)}{
	\texttt{wrap} $\leftarrow$ arreglo de \texttt{p\_archivos} \texttt{Wrapper\_maximums} \\
	\texttt{mutexLista} $\leftarrow$ nuevo mutex \\
	\texttt{it} $\leftarrow$ \texttt{archs.begin} \\
	\texttt{ends} $\leftarrow$ \texttt{archs.end} \\
	\ForEach{entrada de \texttt{wrap}}{
		asignarle direcciones de un nuevo \texttt{CHM}, \texttt{mutexList}, \texttt{it} y \texttt{ends} \\
	}
	crear \texttt{p\_archivos} threads con un puntero a una entrada de \texttt{wrap} y a \texttt{thread\_maximum} \\
	esperar que terminen los \texttt{p\_archivos} threads \\
	\texttt{mapa} $\leftarrow$ nuevo \texttt{CHM} \\
	\texttt{mapa} $\leftarrow$ merge de los mapas en las entradas de \texttt{wrap} \\
	devolver \texttt{mapa.\texttt{maximum}(p\_maximos)} \\
}
\caption{maximum}
\end{algorithm}

Como cada uno de los \texttt{p\_archivos} $threads$ arma su propio mapa, es necesario fusionar todos en uno solo para buscarle el máximo. Esto se hace recorriendo todas los pares de todas las entradas de cada \texttt{tabla}. Por cada par \texttt{(key, k)} recorrido se aplica \texttt{k} veces \texttt{addAndInc(key)} a \texttt{mapa}.

\subsection{Ejercicio 6}

Para este ejercicio había que repetir la funcionalidad del anterior usando la versión concurrente de \texttt{count\_words}, por lo que su código es muy simple.

\begin{algorithm}[H]
\SetKwProg{Fn}{Función}{}{fin}

\SetAlgoLined
\Fn{maximum2(p\_archivosn, p\_maximos, archs)}{
	\texttt{mapa} $\leftarrow$ \texttt{count\_words(p\_archivos, archs)} \\
	devolver \texttt{mapa.maximum(p\_maximos)} \\
}
\caption{maximum2}
\end{algorithm}

En este ejercicio se pide además hacer una comparación con la implementación del ejercicio 5. La experimentación de esto se presenta en la siguiente sección.

\section{Experimentación}

\newpage
\includepdf[scale=0.75,pages=1,pagecommand=\section{Apéndices}
\subsection{Apéndice A - Enunciado}]{./../../tp2-enunciado.pdf}
\includepdf[scale=0.75,pages=2-,pagecommand=]{./../../tp2-enunciado.pdf}
\end{document}

