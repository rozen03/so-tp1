\documentclass[10pt, a4paper, hidelinks]{article}
\usepackage[paper=a4paper, left=2cm, right=2cm, bottom=2cm, top=3cm]{geometry} %ajustar márgnens
\usepackage[latin1]{inputenc}
\usepackage[spanish]{babel}
\usepackage{caratula}
\usepackage{enumitem} 
\usepackage{hyperref}
\usepackage{mathtools}
\usepackage[font=small,labelfont=bf]{caption}
\newcommand\floor[1]{\lfloor#1\rfloor}
\newcommand\ceil[1]{\lceil#1\rceil}
%\usepackage{clrscode3e} Estilo Cormen
\usepackage[spanish,onelanguage,ruled,vlined,nofillcomment]{algorithm2e}
\usepackage{algpseudocode}
\usepackage{xcolor}
\usepackage[final]{pdfpages} % para agregar el enunciado
%%%%%%%%%%%%%% Formato de párrafos %%%%%%%%%%%%%%%%%%
\setlength{\parindent}{2em}
\setlength{\parskip}{3pt}
%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
\usepackage{fancyhdr}
\usepackage{lastpage}
\setlength{\intextsep}{0.2cm}
\pagestyle{fancy}
\lhead{Sistemas Operativos}
\rhead{$1^{\mathrm{er}}$ cuatrimestre de 2018}

\LinesNumbered
\DontPrintSemicolon

\newcommand{\comp}[1]{$\mathcal{O}(#1)$}

%%%%%%%%%%%%%%%%%%% Macro para comentar codigo %%%%%%%%%%%%%%%%%%%%%%%%%
\newcommand{\comentario}[1]{
\SetKwComment{Comment}{/* }{ */}
\textcolor{blue}{\Comment*[h]{{#1}}}
}
%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%

\begin{document}

\materia{Sistemas Operativos}
\submateria{Primer cuatrimestre del 2018}
\titulo{Trabajo Práctico 1: $pthreads$}
\integrante{Budiño, Gabriel Fabricio}{046/16}{gabriel.f.budi@gmail.com} % obligatorio 
\integrante{Garro, Damián Eugenio}{354/16}{damian.garro.mst@gmail.com} % obligatorio 
\integrante{Rozenberg, Uriel Jonathan}{838/12}{rozenberguriel@gmail.com} % obligatorio 

\maketitle

\tableofcontents
\pagenumbering{gobble}

\pagebreak
\pagenumbering{arabic}
\cfoot{\thepage /\pageref{LastPage}}

\section{Introducción}
Para este trabajo se debía implementar la clase ConcurrentHashMap, una tabla de $hash$ abierta con interfaz de Map (i.e, diccionario) preparada para ser usada por $threads$ concurrentes. 

Se presenta en este informe un breve resumen de la resolución de cada ejercicio y la experimentación y pruebas realizadas. En el Apéndice A se encuentra el enunciado del trabajo.


\section{Resolución}
\subsection{Ejercicio 1}

El primer paso era completar la clase \texttt{ListaAtomica} entregada por la cátedra implementando \texttt{push\_front} de manera que no haya peligro de $race$ $conditions$. 

Para esta operación se crea un nuevo nodo con el valor pasado a como parámetro, $nuevo$, y se hace que apunte como siguiente al actual primer nodo, $head$. Acá faltaría solo asignar $nuevo$ a $head$ de modo que éste sea el actual primer nodo, pero podría pasar que entre la asignación de $nuevo\rightarrow next$ y este último paso alguien más haga un push\_front, no cumpliendo así la condición de que no haya peligro de $race$ $conditions$. Para resolver esto, se realiza esa asignación de la siguiente manera:

while (not atomic\_compare\_exchange\_weak(\&$head$, \&$nuevo\rightarrow next$,$nuevo$))

La función dentro de la guarda se comporta así:
\begin{itemize}
\item Si $head$ es igual a $nuevo\rightarrow next$ (i.e, si el $head$ no cambio desde que hicimos que $nuevo$ lo apunte), devuelve True y asigna a $head$, $nuevo$.
\item Si se da el caso contrario (i.e, el $head$ cambio desde que hicimos que $nuevo$ lo apunte), devuelve False y asigna a $nuevo\rightarrow next$, $head$, es decir, hace que $nuevo$ apunte al $head$ correcto.
\end{itemize}

Como la misma se encutra negada dentro de un while, solo se vuelve del llamado de push\_front cuando no hay peligro de incoherencias a causa del orden de ejecución.

Luego habia que implementar la clase \texttt{ConcurrentHashMap}, cuya representación interna es un vector de listas de pares de 26 entradas, \texttt{tabla} (una por cada letra) y un vector de mutexs (mutexes?), \texttt{mutexes} de igual cantidad de entradas.

Para el constructor, \texttt{ConcurrentHashMap()}, simplemente se crea en cada entrada de \texttt{tabla} una nueva lista de pares vacía.

Para la función \texttt{void addAndInc(string key)} se debía garantizar contensión solo en caso de colisión de $hash$. Para lograr esto, se hace $locking$ en cada entrada de \texttt{tabla} usando el arreglo de mutexs \texttt{mutexes}, de manera que ejecuciones concurrentes se permitan siempre que se trate de escrituras a distintas listas.  


\begin{algorithm}[H]

\SetKwProg{Fn}{Función}{}{fin}

\SetAlgoLined
\Fn{addAndInc($key$)}{
	$i$ $\leftarrow$ función de hash de $key$ \\
	\texttt{mutexes}[$i$].lock \\
	iterar \texttt{tabla}[$i$] buscando $key$ \\
	\If{está} {sumar 1 a su valor}
    \Else{\texttt{tabla}[$i$].push\_front($key$)}
    \texttt{mutexes}[$i$].unlock \\
}
\caption{addAndInc}
\end{algorithm} 

Para la función \texttt{bool member(string key)}, simplemente se obtiene $i$ de la misma forma que antes y se recorre la entrada correspondiente de \texttt{tabla} con un iterador, si el elemento está se devuelve True y en caso contrario se devuelve False.

Para función \texttt{pair<string, unsigned int>maximum(unsigned int nt)} se definieron una una estructura y una función auxiliar, así que primero explicamos eso.

Se definió antes una estructura \texttt{Busqueda}, compuesta por un un puntero a lista de par \texttt{mapa}, un entero atómico \texttt{contador}, un par \texttt{max} y un mutex \texttt{mtx\_max}. Para construir una instancia se inicia \texttt{contador} en 0, \texttt{max} en ($" "$, 0) y \texttt{mapa} como una copia de un puntero de lista de par pasada como parámetro.

También se definió la función \texttt{void* buscador(void* data)}, cuyo pseudocódigo es el siguiente.

\begin{algorithm}[H]
\SetKwProg{Fn}{Función}{}{fin}

\SetAlgoLined
\Fn{buscador($data$)}{
	$busqueda$ $\leftarrow$ $data$ como puntero a \texttt{Busqueda} \\
	$max$ $\leftarrow$ ($""$, 0) \\
	\While{\texttt{true}} {
		$i$ $\leftarrow$ $busqueda$.contador++ \\
		\If{$i > 25$} {terminar}	
		iterar $busqueda$.mapa[$i$] \\
		\If{algún elemento tiene valor mayor al valor de $max$}{
		actualizar $max$ con ese elemento		
		}
	}
	$busqueda$.\texttt{mtx\_max}.lock \\
	\If{el valor de $max$ es mayor que el del $busqueda$.max}{
		$busqueda$.max $\leftarrow$ $max$ \\
	}
	$busqueda$.\texttt{mtx\_max}.unlock \\
}
\caption{buscador}
\end{algorithm} 

Originalmente la guarda del \texttt{while} era $i < 26$, pero vimos que un scheduling particular podría traer errores luego haciendo que un $thread$ intente iterar una entrada mayor a 25, por lo que se cambio la guarda a \texttt{true} y luego de la asignación de $i$, si resulta este ser mayor o igual a 26 se hace un \texttt{break}. La única sección crítica acá es la actualización del máximo, que se resolvió usando $locking$ con el mutex interno de la estructura \texttt{Busqueda}.

Ahora, haciendo uso de la estructura y la función mencionadas, el pseudocódigo de \texttt{maximum} es el siguiente.

\begin{algorithm}[H]
\SetKwProg{Fn}{Función}{}{fin}

\SetAlgoLined
\Fn{maximum($nt$)}{
	lock a todas las entradas de \texttt{mutexes} \\
	$busqueda$ $\leftarrow$ puntero a \texttt{Busqueda} construida de \texttt{tabla} \\
	crear $nt$ threads y pasarles $busqueda$ y \texttt{buscador} como punto de inicio \\
	esperar que terminen los $nt$ threads \\
	unlock a todas las entradas de \texttt{mutexes} \\
	devolver $busqueda.max$
}
\caption{maximum}
\end{algorithm} 

Este ejercicio pedía concurrencia interna, la cual se logra usando el entero atómico \texttt{contador}, esto me asegura que durante la ejecución de \texttt{maximum} cada $thread$ va a trabajar sobre una entrada diferente. Aún así, para asegurarnos de que no sea concurrente con \texttt{addAndInc} se debe hacer lock a todos las entradas de \texttt{mutexes} y unlock solo al terminar. 

\subsection{Ejercicio 2}
En este punto no debíamos preocuparnos por la concurrencia. Así que la función  \texttt{count\_words(string arch)} es simplemente abrir el arhivo $arch$ e ir pasando los strings capturados a un \texttt{ConcurrentHashMap} haciendo uso de \texttt{addAndInc}.

En lugar de hacer esto diréctamente, implementamos una función \texttt{meterEnMapa(ConcurrentHashMap* mapa,string arch)} que toma un puntero a \texttt{ConcurrentHashMap} y un archivo y hace lo descripto anteriormente. Esto es porque es algo que vamos a usar mucho. Luego, \texttt{count\_words(string arch)} solo crea un \texttt{ConcurrentHashMap} $mapa$ y lo llena usando \texttt{meterEnMapa} antes de devolverlo.

\subsection{Ejercicio 3}
Para este ejercicio se volvieron a definir una estructura y una función para ayudarnos. La estructura \texttt{WrapperCountWords1} consta de un puntero a \texttt{ConcurrentHashMap mapa} y un \texttt{string arch}. La función \texttt{void* thread\_count\_words1(void* data)} castea $data$ a un puntero a \texttt{WrapperCountWords1} $wrap$ y luego llama a \texttt{meterEnMapa} con $wrap\rightarrow mapa$ y $wrap\rightarrow arch$ como parámetros.

Usando la funció y la estructura recien definidas, el pseudocódigo de \texttt{count\_words} es el siguiente.

\begin{algorithm}[H]
\SetKwProg{Fn}{Función}{}{fin}

\SetAlgoLined
\Fn{count\_words($archs$)}{
	$nt$ $\leftarrow$ largo de $archs$ \\
	$mapa$ $\leftarrow$ nuevo \texttt{ConcurrentHashMap} \\
	$wrap$ $\leftarrow$ arreglo de $nt$ \texttt{WrapperCountWords1} \\
	\ForEach{entrada de $wrap$}{
		asignarle un archivo disntinto de $archs$ y una referencia a $mapa$	
	}
	crear $nt$ threads y pasarle una entrada de $wrap$ y \texttt{thread\_count\_words1} como punto de inicio \\
	esperar que terminen los $nt$ threads \\
	devolver $mapa$
}
\caption{count\_words}
\end{algorithm} 


\subsection{Ejercicio 4}
\subsection{Ejercicio 5}
\subsection{Ejercicio 6}

\section{Experimentación}

\newpage
\includepdf[scale=0.75,pages=1,pagecommand=\section{Apéndices}
\subsection{Apéndice A - Enunciado}]{./../../tp2-enunciado.pdf}
\includepdf[scale=0.75,pages=2-,pagecommand=]{./../../tp2-enunciado.pdf}
\end{document}

