\documentclass[10pt, a4paper, hidelinks]{article}
\usepackage[paper=a4paper, left=2cm, right=2cm, bottom=2cm, top=3cm]{geometry} %ajustar márgnens
\usepackage[latin1]{inputenc}
\usepackage[spanish]{babel}
\usepackage{caratula}
\usepackage{enumitem} 
\usepackage{hyperref}
\usepackage{mathtools}
\usepackage[font=small,labelfont=bf]{caption}
\newcommand\floor[1]{\lfloor#1\rfloor}
\newcommand\ceil[1]{\lceil#1\rceil}
%\usepackage{clrscode3e} Estilo Cormen
\usepackage[spanish,onelanguage,ruled,vlined,nofillcomment]{algorithm2e}
\usepackage{algpseudocode}
\usepackage{xcolor}
\usepackage[final]{pdfpages} % para agregar el enunciado
%%%%%%%%%%%%%% Formato de párrafos %%%%%%%%%%%%%%%%%%
\setlength{\parindent}{2em}
\setlength{\parskip}{3pt}
%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
\usepackage{fancyhdr}
\usepackage{lastpage}
\setlength{\intextsep}{0.2cm}
\pagestyle{fancy}
\lhead{Sistemas Operativos}
\rhead{$1^{\mathrm{er}}$ cuatrimestre de 2018}

\LinesNumbered
\DontPrintSemicolon

\newcommand{\comp}[1]{$\mathcal{O}(#1)$}

%%%%%%%%%%%%%%%%%%% Macro para comentar codigo %%%%%%%%%%%%%%%%%%%%%%%%%
\newcommand{\comentario}[1]{
\SetKwComment{Comment}{/* }{ */}
\textcolor{blue}{\Comment*[h]{{#1}}}
}
%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%

\begin{document}

\materia{Sistemas Operativos}
\submateria{Primer cuatrimestre del 2018}
\titulo{Trabajo Práctico 1: \texttt{pthreads}}
\integrante{Budiño, Gabriel Fabricio}{046/16}{gabriel.f.budi@gmail.com} % obligatorio 
\integrante{Garro, Damián Eugenio}{354/16}{damian.garro.mst@gmail.com} % obligatorio 
\integrante{Rozenberg, Uriel Jonathan}{838/12}{rozenberguriel@gmail.com} % obligatorio 

\maketitle

\tableofcontents
\pagenumbering{gobble}

\pagebreak
\pagenumbering{arabic}
\cfoot{\thepage /\pageref{LastPage}}

\section{Introducción}
Para este trabajo se debía implementar la clase ConcurrentHashMap, una tabla de $hash$ abierta con interfaz de Map (i.e, diccionario) preparada para ser usada por $threads$ concurrentes. 

Se presenta en este informe un breve resumen de la resolución de cada ejercicio y la experimentación y pruebas realizadas. En el Apéndice A se encuentra el enunciado del trabajo.


\section{Resolución}
\subsection{Ejercicio 1}

El primer paso era completar la clase \texttt{ListaAtomica} entregada por la cátedra implementando \texttt{push\_front} de manera que sea \textit{atómica} y no haya peligro de $race$ $conditions$. 

Para esta operación se crea un nuevo nodo con el valor pasado a como parámetro, \texttt{nuevo}, y se hace que apunte como siguiente al actual primer nodo, \texttt{head}. Acá faltaría solo asignar \texttt{nuevo} a \texttt{head} de modo que éste sea el actual primer nodo, pero podría pasar que entre la asignación de \texttt{nuevo$\rightarrow$next} y este último paso alguien más haga un \texttt{push\_front}, no cumpliendo así la condición de que no haya peligro de $race$ $conditions$. Para resolver esto, se realiza esa asignación de la siguiente manera:

\texttt{while (not atomic\_compare\_exchange\_weak(\&head, \&nuevo$\rightarrow$next,nuevo))}

La función dentro de la guarda se comporta así, de forma atómica:
\begin{itemize}
\item Si \texttt{head} es igual a \texttt{nuevo$\rightarrow$next} (i.e, si el \texttt{head} no cambió desde que hicimos que \texttt{nuevo} lo apunte), devuelve True y asigna a \texttt{head}, \texttt{nuevo}.
\item Si se da el caso contrario (i.e, el \texttt{head} cambio desde que hicimos que \texttt{nuevo} lo apunte), devuelve False y asigna a \texttt{nuevo$\rightarrow$next}, \texttt{head}, es decir, hace que \texttt{nuevo} apunte al \texttt{head} correcto.
\end{itemize}

Como la misma se encuentra negada dentro de un while, solo se vuelve del llamado de \texttt{push\_front} cuando no hay peligro de incoherencias a causa del orden de ejecución.

Luego había que implementar la clase \texttt{ConcurrentHashMap}, cuya representación interna es un vector de listas de pares de 26 entradas, \texttt{tabla} (una por cada letra) y un vector de mutex, \texttt{mutexes} de igual cantidad de entradas. 

Para el constructor, \texttt{ConcurrentHashMap()}, simplemente se crea en cada entrada de \texttt{tabla} una nueva lista de pares vacía.

Para la función \texttt{void addAndInc(string key)} se debía garantizar contensión solo en caso de colisión de $hash$. Para lograr esto, se hace $locking$ en la entrada de \texttt{tabla} que se va a modificar usando el arreglo \texttt{mutexes}, de manera que ejecuciones concurrentes se permitan siempre que se trate de escrituras a distintas listas.  


\begin{algorithm}[H]

\SetKwProg{Fn}{Función}{}{fin}

\SetAlgoLined
\Fn{addAndInc(key)}{
	\texttt{i} $\leftarrow$ función de hash de \texttt{key} \\
	\texttt{mutexes[i].lock} \\
	iterar \texttt{tabla[i]} buscando \texttt{key} \\
	\If{está} {sumar 1 a su valor}
    \Else{\texttt{tabla[i].push\_front(key)}}
    \texttt{mutexes[i].unlock} \\
}
\caption{addAndInc}
\end{algorithm} 

Para la función \texttt{bool member(string key)}, simplemente se obtiene \texttt{i} de la misma forma que antes y se recorre la entrada correspondiente de \texttt{tabla} con un iterador, si el elemento está se devuelve True y en caso contrario se devuelve False. Esta operación es \textit{wait free} ya que no se aplica ningún mecanismo de $locking$. Podría ocurrir que en el medio de la operación se ejecute un \texttt{push\_front} del elemento buscado, y que \texttt{member} devolviese False o True dependiendo si ya había empezado a recorrer la entrada de la tabla o no. Esto no es un problema, porque ambos resultados se corresponden con una posible ejecución secuencial de las operaciones.

Para la función \texttt{pair<string, unsigned int>maximum(unsigned int nt)} se definieron una una estructura y una función auxiliar, así que primero explicamos eso.

Se definió antes una estructura \texttt{Busqueda}, compuesta por un un puntero \texttt{ConcurrentHashMap} \texttt{mapa}, un entero atómico \texttt{contador}, un par \texttt{max} y un mutex \texttt{mtx\_max}. 

También se definió la función \texttt{void* buscador(void* data)}, cuyo pseudocódigo es el siguiente.

\begin{algorithm}[H]
\SetKwProg{Fn}{Función}{}{fin}

\SetAlgoLined
\Fn{buscador(data)}{
	\texttt{busqueda $\leftarrow$ data}como puntero a \texttt{Busqueda} \\
	\texttt{max} $\leftarrow$ \texttt{($``"$, 0)} \\
	\While{\texttt{true}} {
		\texttt{i $\leftarrow$ busqueda.contador++} \\
		\If{\texttt{i} $> 25$} {terminar}	
		iterar \texttt{busqueda.mapa[i]}\\
		\If{algún elemento tiene valor mayor al valor de \texttt{max}}{
		actualizar \texttt{max} con ese elemento		
		}
	}
	\texttt{busqueda.mtx\_max.lock} \\
	\If{el valor de \texttt{max} es mayor que el del \texttt{busqueda.max}}{
		\texttt{busqueda.max $\leftarrow$ max} \\
	}
	\texttt{busqueda.mtx\_max.unlock} \\
}
\caption{buscador}
\end{algorithm} 

Originalmente la guarda del \texttt{while} era \texttt{i} $< 26$, pero vimos que un scheduling particular podría traer errores luego haciendo que un $thread$ intente iterar una entrada mayor a 25, por lo que se cambio la guarda a \texttt{true} y luego de la asignación de \texttt{i}, si resulta este ser mayor o igual a 26 se hace un \texttt{break}. La única sección crítica acá es la actualización del máximo, que se resolvió usando $locking$ con el mutex interno de la estructura \texttt{Busqueda}.

Ahora, haciendo uso de la estructura y la función mencionadas, el pseudocódigo de \texttt{maximum} es el siguiente.

\begin{algorithm}[H]
\SetKwProg{Fn}{Función}{}{fin}

\SetAlgoLined
\Fn{maximum(nt)}{
	lock a todas las entradas de \texttt{mutexes} \\
	\texttt{busqueda} $\leftarrow$ nueva \texttt{Busqueda} \\
	\texttt{busqueda.mapa} $\leftarrow$ \texttt{tabla} \\
	\texttt{busqueda.contador} $\leftarrow$ \texttt{0} \\
	\texttt{busqueda.max} $\leftarrow$ \texttt{($``"$, 0)} \\
	crear \texttt{nt} threads y pasarles \texttt{busqueda} y la función \texttt{buscador} como punto de inicio \\
	esperar que terminen los \texttt{nt} threads \\
	unlock a todas las entradas de \texttt{mutexes} \\
	devolver \texttt{busqueda.max}
}
\caption{maximum}
\end{algorithm} 

Este ejercicio pedía concurrencia interna, la cual se logra usando el entero atómico \texttt{contador}, esto me asegura que durante la ejecución de \texttt{maximum} cada $thread$ va a trabajar sobre una entrada diferente. Aún así, para asegurarnos de que no sea concurrente con \texttt{addAndInc} se debe hacer lock a todos las entradas de \texttt{mutexes} y unlock solo al terminar. 

\subsection{Ejercicio 2}
En este punto no debíamos preocuparnos por la concurrencia. Así que la función  \texttt{count\_words(string arch)} es simplemente abrir el arhivo $arch$ e ir pasando los strings capturados a un \texttt{ConcurrentHashMap} haciendo uso de \texttt{addAndInc}.

En lugar de hacer esto diréctamente, implementamos una función \texttt{meterEnMapa(ConcurrentHashMap* mapa,string arch)} que toma un puntero a \texttt{ConcurrentHashMap} y un archivo y hace lo descripto anteriormente. Esto es porque es algo que vamos a usar mucho. Luego, \texttt{count\_words(string arch)} solo crea un \texttt{ConcurrentHashMap} $mapa$ y lo llena usando \texttt{meterEnMapa} antes de devolverlo.

\subsection{Ejercicio 3}
Para este ejercicio se volvieron a definir una estructura y una función para ayudarnos. La estructura \texttt{Wrapper\_count\_words1} consta de un puntero a \texttt{ConcurrentHashMap mapa} y un \texttt{string arch}. La función \texttt{void* thread\_count\_words1(void* data)} castea $data$ a un puntero a \texttt{Wrapper\_count\_words1} $wrap$ y luego llama a \texttt{meterEnMapa} con $wrap\rightarrow mapa$ y $wrap\rightarrow arch$ como parámetros.

Usando la función y la estructura recien definidas, el pseudocódigo de \texttt{count\_words} es el siguiente.

\begin{algorithm}[H]
\SetKwProg{Fn}{Función}{}{fin}

\SetAlgoLined
\Fn{count\_words($archs$)}{
	$nt$ $\leftarrow$ largo de $archs$ \\
	$mapa$ $\leftarrow$ nuevo \texttt{ConcurrentHashMap} \\
	$wrap$ $\leftarrow$ arreglo de $nt$ \texttt{Wrapper\_count\_words1} \\
	\ForEach{entrada de $wrap$}{
		asignarle un archivo disntinto de $archs$ y la dirección de $mapa$	
	}
	crear $nt$ threads y pasarle una entrada de $wrap$ y \texttt{thread\_count\_words1} como punto de inicio \\
	esperar que terminen los $nt$ threads \\
	devolver $mapa$
}
\caption{count\_words}
\end{algorithm} 


\subsection{Ejercicio 4}
Se definió la estructura \texttt{Wrapper\_count\_words2}, que consta de un puntero a \texttt{ConcurrentHashMap mapa}, un puntero a mutex \texttt{mutexLista} y dos iteradores de lista de string, \texttt{it} y \texttt{ends}.

La función \texttt{thread\_count\_words2} tiene el siguiente pseudocodigo:

\begin{algorithm}[H]
\SetKwProg{Fn}{Función}{}{fin}

\SetAlgoLined
\Fn{thread\_count\_words2($data$)}{
	$wrap$ $\leftarrow$ $data$ como puntero a \texttt{Wrapper\_count\_words2} \\
	$arch$ $\leftarrow$ nuevo string \\
	\While{true}{
		$wrap.mutexLista$.lock \\
		\If{$wrap.it$ == $wrap.ends$}{
			$wrap.mutexLista$.unlock \\
			terminar	
		}
		$arch$ $\leftarrow$ $wrap.it$ \\
		$wrap.it$++ \\
		$wrap.mutexLista$.unlock \\
		\texttt{meterEnMapa}($wrap.mapa$, $arch$) \\
	}
}
\caption{thread\_count\_words2}
\end{algorithm}

Esta será la función con la que iniciemos los $threads$ de este punto. Usamos los iteradores $it$ y $ends$ para saber cuando se han tomado todos los archivos de la lista, siendo $it$ el que apunta al siguiente archivo aún no tomado y $ends$ el final de la lista. La modificación de estos iteradores está contenida con $locking$ usando el mutex de \texttt{Wrapper\_count\_words2}.

Así, el pseudocódigo de \texttt{count\_words(unsigned int n, list<string>archs)} es el siguiente:

\begin{algorithm}[H]
\SetKwProg{Fn}{Función}{}{fin}

\SetAlgoLined
\Fn{count\_words($n$, $archs$)}{
	$mapa$ $\leftarrow$ nuevo \texttt{ConcurrentHashMap} \\
	$wrap$ $\leftarrow$ nuevo \texttt{Wrapper\_count\_words2} \\
	$wrap.mapa$ $\leftarrow$ dirección de $mapa$ \\
	$wrap.mutexLista$ $\leftarrow$ nuevo mutex \\
	$wrap.it$ $\leftarrow$ $archs$.begin \\
	$wrap.it$ $\leftarrow$ $archs$.end \\
	crear $n$ threads con una referencia a $wrap$ y la función \texttt{thread\_count\_words2} como punto de inicio
	esperar que que terminen los $n$ threads
	devolver $mapa$
}
\caption{count\_words3?(no se como diferenciarla de las otras sin poner la signatura)}
\end{algorithm}

Notar que los $n$ threads comparten el mismo \texttt{ConcurrentHashMap}. Cada uno se encargará de un archivo diferente hasta que no queden más sin cargar en la lista como se vió en la función definida antes, y la contensión está cubierta por \texttt{addAndInc}.

\subsection{Ejercicio 5}

La estructura \texttt{Wrapper\_maximum} es similar a la anterior, consta de un puntero a \texttt{ConcurrentHashMap mapa}, uno a mutex \texttt{mutexLista}, y dos a iteradores de lista de string, \texttt{it} y \texttt{ends}. Básicamente, los que en la anterior eran iteradores, acá son punteros a los mismos.

A su vez, la función auxiliar \texttt{thread\_maximum} es casi idéntica a \texttt{thread\_count\_words2}. La única diferencia es que al tratar con \texttt{it} y \texttt{ends}, hay que desreferenciarlos.

El pseudocódigo de \texttt{maximum(unsigned int p\_archivos, unsigned int p\_maximos, list<string>archs)} es el siguiente:

\begin{algorithm}[H]
\SetKwProg{Fn}{Función}{}{fin}

\SetAlgoLined
\Fn{maximum($p\_archivosn$, $p\_maximos$, $archs$)}{
	$wrap$ $\leftarrow$ arreglo de $p\_archivos$ \texttt{Wrapper\_maximums} \\
	$mutexLista$ $\leftarrow$ nuevo mutex \\
	$it$ $\leftarrow$ $archs$.begin \\
	$ends$ $\leftarrow$ $archs$.end \\
	\ForEach{entrada de $wrap$}{
		asignarle direcciones de un nuevo \texttt{CHM}, $mutexLista$, $it$ y $ends$ \\
	}
	crear $p\_archivos$ threads con una referencia a un entrada de $wrap$ y a \texttt{thread\_maximum} \\
	esperar que terminen los $p\_archivos$ threads \\
	$mapa$ $\leftarrow$ nuevo \texttt{CHM} \\
	$mapa$ $\leftarrow$ merge de los mapas en las entradas de $wrap$ \\
	devolver $mapa$.\texttt{maimum}($p\_maximos$) \\
}
\caption{maximum}
\end{algorithm}


\subsection{Ejercicio 6}

Para este ejercicio había que repetir la funcionalidad del anterior usando la versión concurrente de \texttt{count\_words}, por lo que su código es muy simple.

\begin{algorithm}[H]
\SetKwProg{Fn}{Función}{}{fin}

\SetAlgoLined
\Fn{maximum2($p\_archivosn$, $p\_maximos$, $archs$)}{
	$mapa$ $\leftarrow$ \texttt{count\_words}($p\_archivos$, $archs$) \\
	devolver $mapa$.\texttt{maimum}($p\_maximos$) \\
}
\caption{maximum2}
\end{algorithm}

\section{Experimentación}

\newpage
\includepdf[scale=0.75,pages=1,pagecommand=\section{Apéndices}
\subsection{Apéndice A - Enunciado}]{./../../tp2-enunciado.pdf}
\includepdf[scale=0.75,pages=2-,pagecommand=]{./../../tp2-enunciado.pdf}
\end{document}

