\documentclass[10pt, a4paper, hidelinks]{article}
\usepackage[paper=a4paper, left=2cm, right=2cm, bottom=2cm, top=3cm]{geometry} %ajustar márgnens
\usepackage[latin1]{inputenc}
\usepackage[spanish]{babel}
\usepackage{caratula}
\usepackage{enumitem} 
\usepackage{hyperref}
\usepackage{mathtools}
\usepackage[font=small,labelfont=bf]{caption}
\newcommand\floor[1]{\lfloor#1\rfloor}
\newcommand\ceil[1]{\lceil#1\rceil}
%\usepackage{clrscode3e} Estilo Cormen
\usepackage[spanish,onelanguage,ruled,vlined,nofillcomment]{algorithm2e}
\usepackage{algpseudocode}
\usepackage{xcolor}
\usepackage[final]{pdfpages} % para agregar el enunciado
%%%%%%%%%%%%%% Formato de párrafos %%%%%%%%%%%%%%%%%%
\setlength{\parindent}{2em}
\setlength{\parskip}{3pt}
%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
\usepackage{fancyhdr}
\usepackage{lastpage}
\setlength{\intextsep}{0.2cm}
\pagestyle{fancy}
\lhead{Sistemas Operativos}
\rhead{$1^{\mathrm{er}}$ cuatrimestre de 2018}

\LinesNumbered
\DontPrintSemicolon

\newcommand{\comp}[1]{$\mathcal{O}(#1)$}

%%%%%%%%%%%%%%%%%%% Macro para comentar codigo %%%%%%%%%%%%%%%%%%%%%%%%%
\newcommand{\comentario}[1]{
\SetKwComment{Comment}{/* }{ */}
\textcolor{blue}{\Comment*[h]{{#1}}}
}
%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%

\begin{document}

\materia{Sistemas Operativos}
\submateria{Primer cuatrimestre del 2018}
\titulo{Trabajo Práctico 1: $pthreads$}
\integrante{Budiño, Gabriel Fabricio}{046/16}{gabriel.f.budi@gmail.com} % obligatorio 
\integrante{Garro, Damián Eugenio}{354/16}{damian.garro.mst@gmail.com} % obligatorio 
\integrante{Rozenberg, Uriel Jonathan}{838/12}{rozenberguriel@gmail.com} % obligatorio 

\maketitle

\tableofcontents
\pagenumbering{gobble}

\pagebreak
\pagenumbering{arabic}
\cfoot{\thepage /\pageref{LastPage}}

\section{Introducción}
Para este trabajo se debía implementar la clase ConcurrentHashMap, una tabla de $hash$ abierta con interfaz de Map (i.e, diccionario) preparada para ser usada por $threads$ concurrentes. 

Se presenta en este informe un breve resumen de la resolución de cada ejercicio y la experimentación y pruebas realizadas. En el Apéndice A se encuentra el enunciado del trabajo.
  
\section{Resolución}
\subsection{Ejercicio 1}

El primer paso era completar la clase ListaAtomica entregada por la cátedra implementando push\_front de manera que no haya peligro de $race$ $conditions$. 

Para esta operación se crea un nuevo nodo con el valor pasado a como parámetro, $nuevo$, y se hace que apunte como siguiente al actual primer nodo, $head$. Acá faltaría solo asignar $nuevo$ a $head$ de modo que éste sea el actual primer nodo, pero podría pasar que entre la asignación de $nuevo\rightarrow next$ y este último paso alguien más haga un push\_front, no cumpliendo así la condición de que no haya peligro de $race$ $conditions$. Para resolver esto, se realiza esa asignación de la siguiente manera:

while (not atomic\_compare\_exchange\_weak(\&$head$, \&$nuevo\rightarrow next$,$nuevo$))

La función dentro de la guarda se comporta así:
\begin{itemize}
\item Si $head$ es igual a $nuevo\rightarrow next$ (i.e, si el $head$ no cambio desde que hicimos que $nuevo$ lo apunte), devuelve True y asigna a $head$, $nuevo$.
\item Si se da el caso contrario (i.e, el $head$ cambio desde que hicimos que $nuevo$ lo apunte), devuelve False y asigna a $nuevo\rightarrow next$, $head$, es decir, hace que $nuevo$ apunte al $head$ correcto.
\end{itemize}

Como la misma se encutra negada dentro de un while, solo se vuelve del llamado de push\_front cuando no hay peligro de incoherencias a causa del orden de ejecución.

Luego habia que implementar la clase \texttt{ConcurrentHashMap}, cuya representación interna es un vector de listas de pares de 26 entradas, \texttt{tabla} (una por cada letra) y un vector de mutexs (mutexes?), \texttt{mutexes} de igual cantidad de entradas.

Para el constructor, \texttt{ConcurrentHashMap()}, simplemente se crea en cada entrada de \texttt{tabla} una nueva lista de pares vacía.

Para la función \texttt{void addAndInc(string key)}, se define $i$ como la entrada de \texttt{tabla} a la cual debe ir a parar $key$ en base a su primer caracter (esa es la función de $hash$) y se $lockea$ el mutex en la entrada $i$ de \texttt{mutexes}. Con un iterador se recorre la lista en la entrada $i$ de \texttt{tabla}, si clave existe se incrementa su valor, sino se hace \texttt{push\_front} de la misma. Finalmente se $unlockea$ (no se como ponerle XD) el mutex. 

Para la función \texttt{bool member(string key)}, simplemente se obtiene $i$ de la misma forma que antes y se recorre la entrada correspondiente de \texttt{tabla} con un iterador, si el elemento está se devuelve True y en caso contrario se devuelve False.

La función \texttt{pair<string, unsigned int>maximum(unsigned int nt)} podía ser concurrente con \texttt{member} pero no con \texttt{addAndInc} y además, debía implementarse con concurrencia interna. Antes de explicar la implementación de la función en sí, explicamos una estructura y una función auxiliar definidas para ayudarnos.

Se definió antes una estructura \texttt{Busqueda}, compuesta por un un puntero a lista de par \texttt{mapa}, un entero atómico \texttt{contador}, un par \texttt{max} y un mutex \texttt{mtx\_max}. Para construir una instancia se inicia \texttt{contador} en 0, \texttt{max} en ($" "$, 0) y \texttt{mapa} como una copia de un puntero de lista de par pasada como parámetro.

También se definió la función \texttt{void* buscador(void* data)}. Inicialmente castea $data$ a puntero a \texttt{Busqueda} $busqueda$ e inicia un par local $max$ como ($""$, 0). Luego, dentro de un \texttt{while(true)} se define $i$ como $busqueda\rightarrow contador++$ y se itera la $i$-ésima lista de $busqueda\rightarrow mapa$ actualizando $max$ de manera que quede en éste último el par de máximo valor de esa lista. Originalmente la guarda del \texttt{while} era $i < 26$, pero vimos que un scheduling particular podría traer errores luego haciendo que un $thread$ intente iterar una entrada mayor a 25, por lo que se cambio la guarda a \texttt{true} y luego de la asignación de $i$, si resulta este ser mayor o igual a 26 se hace un \texttt{break}. Finalmente, se lockea $busqueda\rightarrow mtx\_max$ y se actualiza $busqueda\rightarrow max$ al máximo entre él y $max$ antes de unlockear.

Ahora, en cuanto a la implementación de la función en cuestión, primero se lockean todas las entradas de \texttt{mutexes}. Luego se genera un puntero a \texttt{Busqueda} $busqueda$ en base a \texttt{tabla} y $nt$ $threads$ a los que se les pasa $busqueda$ y la función \texttt{buscador} como punto de inicio. Luego de esperar a que los $nt$ $threads$ terminen, se unlockean todas las entradas de \texttt{mutexes} y de devuelve $busqueda\rightarrow max$.
\subsection{Ejercicio 2}
La función  \texttt{ConcurrentHashMap::count words(string arch)} es simplemente abrir el arhivo $arch$ e ir pasando los strings capturados a un \texttt{ConcurrentHashMap} usando la función \texttt{addAndInc}.

En lugar de hacer esto diréctamente, implementamos una función \texttt{meterEnMapa(ConcurrentHashMap* mapa,string arch)} que toma un puntero a \texttt{ConcurrentHashMap} y un archivo y hace lo descripto anteriormente. Esto es porque es algo que vamos a usar mucho. Luego, \texttt{ConcurrentHashMap::count words(string arch)} solo crea un \texttt{ConcurrentHashMap} $mapa$ y lo llena usando \texttt{meterEnMapa} antes de devolverlo.

En este punto no debíamos preocuparnos por la concurrencia. 

\subsection{Ejercicio 3}
Para este ejercicio se volvieron a definir una estructura y una función para ayudarnos. La estructura \texttt{WrapperCountWords1} consta de un puntero a \texttt{ConcurrentHashMap mapa} y un \texttt{string arch}. La función \texttt{void* threadCount\_words1(void* data)} castea $data$ a un puntero a \texttt{WrapperCountWords1} $wrap$ y luego llama a \texttt{meterEnMapa} con $wrap\rightarrow mapa$ y $wrap\rightarrow arch$ como parámetros.

En \texttt{ConcurrentHashMap count\_words(list<string>archs)} incialmente creamos un nuevo \texttt{ConcurrentHashMap} $mapa$ y definimos un entero $nt$ como el largo de $archs$. Luego creamos un arreglo de \texttt{WrapperCountWords1} de $nt$ entradas, $wrap$, donde a cada entrada asignamos un elemento distinto de $archs$ y una referencia a $mapa$, y $nt$ $threads$ a los que les pasamos una entrada de $wrap$ y la función \texttt{threadCount\_words1} como punto de inicio. Finalmente, luego de esperar que todos los $threads$ terminen, devolvemos $mapa$.

\subsection{Ejercicio 4}
\subsection{Ejercicio 5}
\subsection{Ejercicio 6}

\section{Experimentación}

\newpage
\includepdf[scale=0.75,pages=1,pagecommand=\section{Apéndices}
\subsection{Apéndice A - Enunciado}]{./../../tp2-enunciado.pdf}
\includepdf[scale=0.75,pages=2-,pagecommand=]{./../../tp2-enunciado.pdf}
\end{document}

